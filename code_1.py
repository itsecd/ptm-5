# импортируем модуль numpy для работы с массивами и математическими функциями
import numpy as np

# определяем функцию для расчета математического ожидания случайной величины
def mean(x):
    """
    Вычисляет математическое ожидание случайной величины.
    
    Аргументы:
        x (np.array): Массив значений случайной величины.
        
    Возвращает:
        float: Математическое ожидание случайной величины.
    """
    # суммируем все значения в массиве и делим на их количество
    return np.sum(x) / len(x)

# определяем функцию для расчета дисперсии случайной величины
def variance(x):
    """
    Вычисляет дисперсию случайной величины.
    
    Аргументы:
        x (np.array): Массив значений случайной величины.
        
    Возвращает:
        float: Дисперсия случайной величины.
    """
    # вычисляем математическое ожидание случайной величины
    m = mean(x)
    # суммируем квадраты отклонений от математического ожидания и делим на количество значений
    return np.sum((x - m) ** 2) / len(x)

# определяем функцию для расчета стандартного отклонения случайной величины
def std(x):
    """
    Вычисляет стандартное отклонение случайной величины.
    
    Аргументы:
        x (np.array): Массив значений случайной величины.
        
    Возвращает:
        float: Стандартное отклонение случайной величины.
    """
    # вычисляем дисперсию случайной величины и извлекаем из нее квадратный корень
    return np.sqrt(variance(x))

# определяем функцию для расчета медианы случайной величины
def median(x):
    """
    Вычисляет медиану случайной величины.
    
    Аргументы:
        x (np.array): Массив значений случайной величины.
        
    Возвращает:
        float: Медиана случайной величины.
    """
    # сортируем массив по возрастанию
    x = np.sort(x)
    # определяем индекс среднего элемента
    mid = len(x) // 2
    # если количество элементов нечетное, то возвращаем средний элемент
    if len(x) % 2 == 1:
        return x[mid]
    # иначе возвращаем среднее арифметическое двух средних элементов
    else:
        return (x[mid - 1] + x[mid]) / 2

# определяем функцию для расчета моды случайной величины
def mode(x):
    """
    Вычисляет моду случайной величины.
    
    Аргументы:
        x (np.array): Массив значений случайной величины.
        
    Возвращает:
        np.array: Массив значений, которые являются модами случайной величины.
    """
    # создаем словарь для подсчета частоты встречаемости каждого значения
    freq = {}
    # проходим по всем значениям в массиве
    for value in x:
        # если значение уже есть в словаре, то увеличиваем его частоту на единицу
        if value in freq:
            freq[value] += 1
        # иначе добавляем значение в словарь с частотой равной единице
        else:
            freq[value] = 1
    # определяем максимальную частоту в словаре
    max_freq = max(freq.values())
    # создаем пустой список для мод
    modes = []
    # проходим по всем значениям в словаре
    for value, frequency in freq.items():
        # если частота равна максимальной, то добавляем значение в список мод
        if frequency == max_freq:
            modes.append(value)
    # возвращаем список мод в виде массива
    return np.array(modes)

# определяем функцию для расчета квантилей случайной величины
def quantile(x, p):
    """
    Вычисляет квантиль случайной величины заданного порядка.
    
    Аргументы:
        x (np.array): Массив значений случайной величины.
        p (float): Порядок квантиля (от 0 до 1).
        
    Возвращает:
        float: Квантиль случайной величины заданного порядка.
    """
    # проверяем, что порядок квантиля лежит в допустимом диапазоне
    if p < 0 or p > 1:
        raise ValueError("p must be between 0 and 1")
    # сортируем массив по возрастанию
    x = np.sort(x)
    # определяем индекс квантиля
    index = int(p * len(x))
    # возвращаем значение по индексу
    return x[index]

# определяем функцию для расчета ковариации двух случайных величин
def covariance(x, y):
    """
    Вычисляет ковариацию двух случайных величин.
    
    Аргументы:
        x (np.array): Массив значений первой случайной величины.
        y (np.array): Массив значений второй случайной величины.
        
    Возвращает:
        float: Ковариация двух случайных величин.
    """
    # проверяем, что массивы имеют одинаковую длину
    if len(x) != len(y):
        raise ValueError("x and y must have the same length")
    # вычисляем математические ожидания случайных величин
    mx = mean(x)
    my = mean(y)
    # суммируем произведения отклонений от математических ожиданий и делим на количество значений
    return np.sum((x - mx) * (y - my)) / len(x)

# определяем функцию для расчета коэффициента корреляции двух случайных величин
def correlation(x, y):
    """
    Вычисляет коэффициент корреляции двух случайных величин.
    
    Аргументы:
        x (np.array): Массив значений первой случайной величины.
        y (np.array): Массив значений второй случайной величины.
        
    Возвращает:
        float: Коэффициент корреляции двух случайных величин.
    """
    # вычисляем ковариацию и стандартные отклонения случайных величин
    cov = covariance(x, y)
    sx = std(x)
    sy = std(y)
    # делим ковариацию на произведение стандартных отклонений
    return cov / (sx * sy)
